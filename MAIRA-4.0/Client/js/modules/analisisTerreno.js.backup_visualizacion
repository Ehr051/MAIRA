/**
 * üó∫Ô∏è M√ìDULO AN√ÅLISIS DE TERRENO - MAIRA 4.0
 * 
 * Sistema de capas m√∫ltiples para an√°lisis integral del terreno:
 * - üìê Altimetr√≠a (pendientes, COTA, talud)
 * - üå≥ Vegetaci√≥n (bosque, arboleda, matorrales)
 * - üöß Obst√°culos (r√≠os, edificaciones, minas)
 * - üõ£Ô∏è Avenidas de aproximaci√≥n
 * - üìä An√°lisis combinado
 * 
 * Integra algoritmos BV8:
 * - Algoritmo Horn (pendientes 3x3)
 * - OCOTA (intervisibilidad)
 * - Transitabilidad (suelo√óclima√óveh√≠culo√ópendiente)
 */

class AnalisisTerreno {
    constructor(map) {
        this.map = map;
        this.modalActivo = false;
        this.poligonoActual = null;
        this.capaResultados = null;
        this.drawControl = null;
        
        // Configuraci√≥n
        this.config = {
            apiUrl: 'http://localhost:5001/api/terreno',
            coloresPendientes: {
                '0-5': '#2ecc71',      // Verde - Transitable
                '5-15': '#f1c40f',     // Amarillo - Precauci√≥n
                '15-30': '#e67e22',    // Naranja - Dif√≠cil
                '30+': '#e74c3c'       // Rojo - Muy dif√≠cil
            }
        };
        
        console.log('üó∫Ô∏è M√≥dulo An√°lisis de Terreno inicializado');
    }

    /**
     * Inicializa el m√≥dulo
     */
    inicializar() {
        this.crearBotonHerramientas();
        this.crearModal();
        this.inicializarLeafletDraw();
        console.log('‚úÖ An√°lisis de Terreno listo');
    }

    /**
     * Crea el bot√≥n en el men√∫ de Herramientas
     */
    crearBotonHerramientas() {
        const menuHerramientas = document.getElementById('herramientas-menu');
        if (!menuHerramientas) {
            console.warn('‚ö†Ô∏è No se encontr√≥ el men√∫ de herramientas');
            return;
        }

        // Crear bot√≥n despu√©s de "C√°lculo de Marcha"
        const btnCalculoMarcha = document.getElementById('btnCalculoMarcha');
        if (btnCalculoMarcha) {
            const btnAnalisisTerreno = document.createElement('a');
            btnAnalisisTerreno.href = '#';
            btnAnalisisTerreno.id = 'btnAnalisisTerreno';
            btnAnalisisTerreno.innerHTML = '<i class="fas fa-mountain"></i> An√°lisis de Terreno';
            btnAnalisisTerreno.addEventListener('click', (e) => {
                e.preventDefault();
                this.abrirModal();
            });

            btnCalculoMarcha.insertAdjacentElement('afterend', btnAnalisisTerreno);
            console.log('‚úÖ Bot√≥n "An√°lisis de Terreno" agregado al men√∫');
        }
    }

    /**
     * Crea el modal de an√°lisis de terreno
     */
    crearModal() {
        const modalHTML = `
            <div id="modalAnalisisTerreno" class="modal-analisis-terreno" style="display: none;">
                <div class="modal-analisis-content">
                    <!-- Header -->
                    <div class="modal-analisis-header">
                        <h2><i class="fas fa-mountain"></i> An√°lisis de Terreno</h2>
                        <button class="btn-cerrar-modal" onclick="window.analisisTerreno.cerrarModal()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>

                    <!-- Instrucciones -->
                    <div class="modal-analisis-instrucciones">
                        <p>
                            <i class="fas fa-info-circle"></i>
                            <strong>1.</strong> Dibuje un pol√≠gono en el mapa delimitando la zona a analizar
                        </p>
                        <p>
                            <strong>2.</strong> Configure los par√°metros del an√°lisis
                        </p>
                        <p>
                            <strong>3.</strong> Presione "Analizar Terreno"
                        </p>
                    </div>

                    <!-- Panel de par√°metros -->
                    <div class="modal-analisis-parametros">
                        <h3>‚öôÔ∏è Par√°metros del An√°lisis</h3>
                        
                        <div class="param-group">
                            <label for="selectTipoVehiculo">
                                <i class="fas fa-truck-military"></i> Tipo de Veh√≠culo:
                            </label>
                            <select id="selectTipoVehiculo">
                                <option value="Infanteria">Infanter√≠a (a pie)</option>
                                <option value="TAM">TAM (Tanque Argentino Mediano)</option>
                                <option value="VCTP">VCTP (Veh√≠culo Combate Transporte Personal)</option>
                                <option value="VLEGA">VLEGA (Veh√≠culo Ligero Ej√©rcito Argentino)</option>
                                <option value="Unimog">Unimog (Cami√≥n todo terreno)</option>
                                <option value="VCPC">VCPC (Veh√≠culo Combate Puesto Comando)</option>
                            </select>
                        </div>

                        <div class="param-group">
                            <label for="selectClima">
                                <i class="fas fa-cloud-sun"></i> Condiciones Clim√°ticas:
                            </label>
                            <select id="selectClima">
                                <option value="seco">Seco (normal)</option>
                                <option value="lluvioso">Lluvioso (reducida transitabilidad)</option>
                                <option value="nieve">Nieve (muy reducida)</option>
                            </select>
                        </div>

                        <div class="param-group">
                            <label for="selectTipoAnalisis">
                                <i class="fas fa-layer-group"></i> Capas a Analizar:
                            </label>
                            <div class="checkbox-group">
                                <label>
                                    <input type="checkbox" id="checkPendientes" checked>
                                    üìê Pendientes y Talud
                                </label>
                                <label>
                                    <input type="checkbox" id="checkTransitabilidad" checked>
                                    üöó Transitabilidad
                                </label>
                                <label>
                                    <input type="checkbox" id="checkIntervisibilidad">
                                    üëÅÔ∏è Intervisibilidad (OCOTA)
                                </label>
                                <label>
                                    <input type="checkbox" id="checkVegetacion">
                                    üå≥ Vegetaci√≥n (si disponible)
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Botones de acci√≥n -->
                    <div class="modal-analisis-acciones">
                        <button id="btnDibujarPoligono" class="btn-primary">
                            <i class="fas fa-draw-polygon"></i> Dibujar Pol√≠gono
                        </button>
                        <button id="btnAnalizarTerreno" class="btn-success" disabled>
                            <i class="fas fa-chart-area"></i> Analizar Terreno
                        </button>
                        <button id="btnLimpiarAnalisis" class="btn-secondary">
                            <i class="fas fa-eraser"></i> Limpiar
                        </button>
                    </div>

                    <!-- Panel de resultados (inicialmente oculto) -->
                    <div id="panelResultados" class="modal-analisis-resultados" style="display: none;">
                        <h3>üìä Resultados del An√°lisis</h3>
                        
                        <div id="estadisticasTerreno" class="estadisticas-grid">
                            <!-- Se llenar√° din√°micamente -->
                        </div>

                        <div id="graficoDistribucion" class="grafico-container">
                            <canvas id="chartPendientes"></canvas>
                        </div>

                        <div id="tablaPuntosCriticos" class="tabla-criticos">
                            <!-- Se llenar√° din√°micamente -->
                        </div>
                    </div>

                    <!-- Indicador de carga -->
                    <div id="loadingAnalisis" class="loading-overlay" style="display: none;">
                        <div class="spinner"></div>
                        <p>Analizando terreno...</p>
                    </div>
                </div>
            </div>
        `;

        // Insertar modal en el body
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        // Configurar eventos
        this.configurarEventosModal();
    }

    /**
     * Configura los eventos del modal
     */
    configurarEventosModal() {
        const btnDibujar = document.getElementById('btnDibujarPoligono');
        const btnAnalizar = document.getElementById('btnAnalizarTerreno');
        const btnLimpiar = document.getElementById('btnLimpiarAnalisis');

        if (btnDibujar) {
            btnDibujar.addEventListener('click', () => this.activarDibujoPoligono());
        }

        if (btnAnalizar) {
            btnAnalizar.addEventListener('click', () => this.analizarTerreno());
        }

        if (btnLimpiar) {
            btnLimpiar.addEventListener('click', () => this.limpiarAnalisis());
        }
    }

    /**
     * Inicializa Leaflet.draw para dibujar pol√≠gonos
     */
    inicializarLeafletDraw() {
        if (!L.Draw) {
            console.warn('‚ö†Ô∏è Leaflet.draw no est√° cargado. Agregue la biblioteca.');
            return;
        }

        // Crear capa para los dibujos
        this.capaResultados = new L.FeatureGroup();
        this.map.addLayer(this.capaResultados);

        // Configurar control de dibujo
        this.drawControl = new L.Control.Draw({
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    shapeOptions: {
                        color: '#3498db',
                        weight: 3,
                        fillOpacity: 0.2
                    }
                },
                polyline: false,
                circle: false,
                rectangle: false,
                marker: false,
                circlemarker: false
            },
            edit: {
                featureGroup: this.capaResultados,
                remove: true
            }
        });

        // Eventos de dibujo
        this.map.on(L.Draw.Event.CREATED, (e) => {
            this.capaResultados.clearLayers();
            this.poligonoActual = e.layer;
            this.capaResultados.addLayer(this.poligonoActual);
            
            // Habilitar bot√≥n de an√°lisis
            document.getElementById('btnAnalizarTerreno').disabled = false;
            
            console.log('‚úÖ Pol√≠gono dibujado:', this.poligonoActual.toGeoJSON());
        });

        this.map.on(L.Draw.Event.DELETED, () => {
            this.poligonoActual = null;
            document.getElementById('btnAnalizarTerreno').disabled = true;
        });
    }

    /**
     * Abre el modal de an√°lisis
     */
    abrirModal() {
        const modal = document.getElementById('modalAnalisisTerreno');
        if (modal) {
            modal.style.display = 'block';
            this.modalActivo = true;
            document.body.classList.add('analisis-terreno-activo');
            console.log('üó∫Ô∏è Modal de An√°lisis de Terreno abierto');
        }
    }

    /**
     * Cierra el modal de an√°lisis
     */
    cerrarModal() {
        const modal = document.getElementById('modalAnalisisTerreno');
        if (modal) {
            modal.style.display = 'none';
            this.modalActivo = false;
            document.body.classList.remove('analisis-terreno-activo');
            this.desactivarDibujoPoligono();
        }
    }

    /**
     * Activa el modo de dibujo de pol√≠gono
     */
    activarDibujoPoligono() {
        if (!this.drawControl) {
            alert('Leaflet.draw no est√° disponible. Verifique la carga de bibliotecas.');
            return;
        }

        // Agregar control si no est√° en el mapa
        if (!this.map.hasLayer(this.drawControl)) {
            this.map.addControl(this.drawControl);
        }

        // Activar herramienta de pol√≠gono
        new L.Draw.Polygon(this.map, this.drawControl.options.draw.polygon).enable();
        
        console.log('üñäÔ∏è Modo dibujo de pol√≠gono activado');
    }

    /**
     * Desactiva el modo de dibujo
     */
    desactivarDibujoPoligono() {
        if (this.drawControl && this.map.hasLayer(this.drawControl)) {
            this.map.removeControl(this.drawControl);
        }
    }

    /**
     * Genera una grilla de puntos dentro de un pol√≠gono
     * @param {Array} polygonCoords - Coordenadas del pol√≠gono [[lng, lat], ...]
     * @param {Number} resolution - Resoluci√≥n en metros (default: 100m)
     * @returns {Array} - Array de puntos {lat, lon}
     */
    generarGrillaPuntos(polygonCoords, resolution = 100) {
        // Calcular bounds del pol√≠gono
        const lngs = polygonCoords.map(p => p[0]);
        const lats = polygonCoords.map(p => p[1]);
        
        const minLng = Math.min(...lngs);
        const maxLng = Math.max(...lngs);
        const minLat = Math.min(...lats);
        const maxLat = Math.max(...lats);
        
        // Calcular centro para ajuste de longitud
        const centerLat = (minLat + maxLat) / 2;
        
        // Conversi√≥n metros a grados
        const metersPerDegreeLat = 111320;
        const metersPerDegreeLon = 111320 * Math.cos(centerLat * Math.PI / 180);
        
        const latStep = resolution / metersPerDegreeLat;
        const lonStep = resolution / metersPerDegreeLon;
        
        console.log(`üìê Resoluci√≥n: ${resolution}m ‚Üí ${latStep.toFixed(6)}¬∞ lat, ${lonStep.toFixed(6)}¬∞ lon`);
        
        // Generar puntos
        const points = [];
        const polygon = L.polygon(polygonCoords.map(p => [p[1], p[0]])); // Leaflet usa [lat, lng]
        
        for (let lat = minLat; lat <= maxLat; lat += latStep) {
            for (let lon = minLng; lon <= maxLng; lon += lonStep) {
                // Verificar si el punto est√° dentro del pol√≠gono
                if (polygon.getBounds().contains([lat, lon])) {
                    // Verificaci√≥n m√°s precisa con contains (requiere que el pol√≠gono est√© en el mapa)
                    const latLng = L.latLng(lat, lon);
                    
                    // Usar algoritmo punto-en-pol√≠gono simple
                    if (this.puntoEnPoligono(lat, lon, polygonCoords)) {
                        points.push({ lat, lon });
                    }
                }
            }
        }
        
        console.log(`‚úÖ Grilla: ${points.length} puntos generados (resoluci√≥n ${resolution}m)`);
        return points;
    }

    /**
     * Algoritmo punto-en-pol√≠gono (Ray Casting)
     * @param {Number} lat - Latitud del punto
     * @param {Number} lon - Longitud del punto
     * @param {Array} polygonCoords - Coordenadas del pol√≠gono [[lng, lat], ...]
     * @returns {Boolean}
     */
    puntoEnPoligono(lat, lon, polygonCoords) {
        let inside = false;
        
        for (let i = 0, j = polygonCoords.length - 1; i < polygonCoords.length; j = i++) {
            const xi = polygonCoords[i][0], yi = polygonCoords[i][1];
            const xj = polygonCoords[j][0], yj = polygonCoords[j][1];
            
            const intersect = ((yi > lat) !== (yj > lat))
                && (lon < (xj - xi) * (lat - yi) / (yj - yi) + xi);
            
            if (intersect) inside = !inside;
        }
        
        return inside;
    }

    /**
     * Ejecuta el an√°lisis de terreno
     */
    async analizarTerreno() {
        if (!this.poligonoActual) {
            alert('Primero debe dibujar un pol√≠gono en el mapa.');
            return;
        }

        // Obtener par√°metros
        const vehiculo = document.getElementById('selectTipoVehiculo').value;
        const clima = document.getElementById('selectClima').value;
        const checkPendientes = document.getElementById('checkPendientes').checked;
        const checkTransitabilidad = document.getElementById('checkTransitabilidad').checked;

        // Mostrar indicador de carga
        document.getElementById('loadingAnalisis').style.display = 'flex';

        try {
            // üéØ PASO 1: Generar grilla de puntos dentro del pol√≠gono
            const geoJSON = this.poligonoActual.toGeoJSON();
            const gridPoints = this.generarGrillaPuntos(geoJSON.geometry.coordinates[0], 100); // 100m resoluci√≥n
            
            console.log(`üìê Grilla generada: ${gridPoints.length} puntos para an√°lisis`);
            
            // Preparar datos para API
            const requestData = {
                poligono: geoJSON.geometry.coordinates,
                puntos: gridPoints, // ‚Üê Puntos de la grilla
                vehiculo: vehiculo,
                clima: clima,
                capas: {
                    pendientes: checkPendientes,
                    transitabilidad: checkTransitabilidad
                }
            };

            console.log('üì° Enviando solicitud de an√°lisis:', requestData);

            // Llamar a la API
            const response = await fetch(`${this.config.apiUrl}/analizar`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                throw new Error(`Error HTTP: ${response.status}`);
            }

            const resultados = await response.json();
            console.log('‚úÖ Resultados recibidos:', resultados);

            // Mostrar resultados
            this.mostrarResultados(resultados);

            // Pintar overlay en el mapa
            if (checkPendientes) {
                this.pintarMapaCalor(resultados);
            }

        } catch (error) {
            console.error('‚ùå Error en an√°lisis de terreno:', error);
            alert(`Error al analizar el terreno: ${error.message}\n\nVerifique que el servidor API est√© corriendo.`);
        } finally {
            // Ocultar indicador de carga
            document.getElementById('loadingAnalisis').style.display = 'none';
        }
    }

    /**
     * Muestra los resultados del an√°lisis
     */
    mostrarResultados(resultados) {
        const panelResultados = document.getElementById('panelResultados');
        const estadisticas = document.getElementById('estadisticasTerreno');

        // Mostrar panel
        panelResultados.style.display = 'block';

        // Generar estad√≠sticas
        const statsHTML = `
            <div class="stat-card">
                <i class="fas fa-chart-line"></i>
                <h4>Pendiente Promedio</h4>
                <p class="stat-value">${resultados.pendiente_promedio?.toFixed(2) || 'N/A'}¬∞</p>
            </div>
            <div class="stat-card">
                <i class="fas fa-angle-double-up"></i>
                <h4>Pendiente M√°xima</h4>
                <p class="stat-value">${resultados.pendiente_maxima?.toFixed(2) || 'N/A'}¬∞</p>
            </div>
            <div class="stat-card">
                <i class="fas fa-road"></i>
                <h4>% Transitable</h4>
                <p class="stat-value">${resultados.pct_transitable?.toFixed(1) || 'N/A'}%</p>
            </div>
            <div class="stat-card">
                <i class="fas fa-exclamation-triangle"></i>
                <h4>Puntos Cr√≠ticos</h4>
                <p class="stat-value">${resultados.puntos_criticos?.length || 0}</p>
            </div>
        `;

        estadisticas.innerHTML = statsHTML;

        // Generar gr√°fico de distribuci√≥n (si Chart.js est√° disponible)
        if (typeof Chart !== 'undefined' && resultados.distribucion_pendientes) {
            this.generarGraficoPendientes(resultados.distribucion_pendientes);
        }
    }

    /**
     * Genera el gr√°fico de distribuci√≥n de pendientes
     */
    generarGraficoPendientes(distribucion) {
        const ctx = document.getElementById('chartPendientes');
        if (!ctx) return;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['0-5¬∞', '5-15¬∞', '15-30¬∞', '>30¬∞'],
                datasets: [{
                    label: 'Distribuci√≥n de Pendientes (%)',
                    data: [
                        distribucion['0-5'] || 0,
                        distribucion['5-15'] || 0,
                        distribucion['15-30'] || 0,
                        distribucion['30+'] || 0
                    ],
                    backgroundColor: [
                        this.config.coloresPendientes['0-5'],
                        this.config.coloresPendientes['5-15'],
                        this.config.coloresPendientes['15-30'],
                        this.config.coloresPendientes['30+']
                    ]
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Porcentaje (%)'
                        }
                    }
                }
            }
        });
    }

    /**
     * Pinta un mapa de calor sobre el pol√≠gono analizado
     */
    pintarMapaCalor(resultados) {
        // TODO: Implementar overlay de colores seg√∫n pendientes
        console.log('üé® Pintando mapa de calor (PENDIENTE)');
    }

    /**
     * Limpia el an√°lisis actual
     */
    limpiarAnalisis() {
        if (this.capaResultados) {
            this.capaResultados.clearLayers();
        }
        this.poligonoActual = null;
        
        document.getElementById('panelResultados').style.display = 'none';
        document.getElementById('btnAnalizarTerreno').disabled = true;
        
        console.log('üßπ An√°lisis limpiado');
    }
}

// Inicializar autom√°ticamente cuando el mapa est√© listo
document.addEventListener('DOMContentLoaded', () => {
    // Esperar a que el mapa est√© disponible
    const checkMap = setInterval(() => {
        if (window.map) {
            window.analisisTerreno = new AnalisisTerreno(window.map);
            window.analisisTerreno.inicializar();
            clearInterval(checkMap);
        }
    }, 100);
});
