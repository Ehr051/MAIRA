/**
 * üéÆ GESTOR DE √ìRDENES V2
 *
 * Sistema central que integra:
 * - OrdenesQueueV2 (cola de √≥rdenes con tiempo real)
 * - PanelCoordinacionOrdenes (visualizaci√≥n timeline)
 * - Men√∫ Radial (interfaz para dar √≥rdenes)
 * - HexGrid (mapa hexagonal)
 * - Subfases de combate (impartici√≥n de √≥rdenes ‚Üí ejecuci√≥n ‚Üí revisi√≥n)
 *
 * @author MAIRA Team
 * @version 2.0
 */

class GestorOrdenesV2 {
    constructor(opciones = {}) {
        // Configuraci√≥n
        this.config = {
            modoDebug: opciones.debug || true,
            duracionTurnoMinutos: opciones.duracionTurnoMinutos || 60, // 1 hora por turno
            velocidadEjecucion: opciones.velocidadEjecucion || 1.0, // 1x = tiempo real
            permitirDeshacer: opciones.permitirDeshacer !== false,
            maxHistorialOrdenes: opciones.maxHistorialOrdenes || 100,
            ...opciones
        };

        // Referencias a sistemas
        this.map = null;
        this.hexGrid = null;
        this.pathfinding = null;
        this.colasOrdenes = new Map(); // Map<equipoId, OrdenesQueueV2>
        this.panelCoordinacion = null;
        this.menuRadial = null;

        // Estado del juego
        this.subfaseActual = 'imparticion'; // imparticion | ejecucion | revision
        this.turnoActual = 1;
        this.tiempoSimuladoMinutos = 0;
        this.jugadorActual = null;
        this.equipoActual = null;

        // Estado de interacci√≥n
        this.unidadSeleccionada = null;
        this.modoOrden = null; // null | 'movimiento' | 'ataque' | 'defensa'
        this.origenOrden = null;
        this.destinoOrden = null;
        this.previewRuta = null;
        this.previewLinea = null;

        // Listeners de eventos
        this.eventListeners = new Map();

        // Estado de √≥rdenes
        this.ordenesValidadas = [];
        this.ordenesEjecutadas = [];
        this.logEventosTurno = [];

        this.log('‚úÖ GestorOrdenesV2 creado');
    }

    /**
     * Inicializa el gestor con las dependencias necesarias
     */
    async inicializar(opciones = {}) {
        this.log('üöÄ Inicializando GestorOrdenesV2...');

        try {
            // Obtener referencias a sistemas existentes
            this.map = opciones.map || window.map;
            this.hexGrid = opciones.hexGrid || window.HexGrid;
            this.menuRadial = opciones.menuRadial || window.MiRadial;

            if (!this.map) throw new Error('Map no disponible');
            if (!this.hexGrid) throw new Error('HexGrid no disponible');

            // ‚ùå NO USAR Pathfinding con HexGrid
            // Las √≥rdenes de MOVIMIENTO deben usar l√≠neas de medici√≥n/marcha
            // Las √≥rdenes de ATAQUE deben marcar: 1) eje de avance 2) objetivo
            this.pathfinding = null; // Sistema de √≥rdenes redise√±ado
            this.log('‚ö†Ô∏è Sistema de √≥rdenes usa l√≠neas de medici√≥n (no pathfinding)');

            // Inicializar colas de √≥rdenes por equipo
            const equipos = opciones.equipos || ['azul', 'rojo'];
            for (const equipo of equipos) {
                const cola = new OrdenesQueueV2(equipo, {
                    debug: this.config.modoDebug,
                    duracionTurnoMinutos: this.config.duracionTurnoMinutos
                });
                this.colasOrdenes.set(equipo, cola);
                this.log(`‚úÖ Cola de √≥rdenes creada para equipo ${equipo}`);
            }

            // Inicializar panel de coordinaci√≥n
            if (typeof PanelCoordinacionOrdenes !== 'undefined') {
                this.panelCoordinacion = new PanelCoordinacionOrdenes({
                    contenedor: opciones.contenedorPanel || 'panel-coordinacion-container',
                    duracionTurnoMinutos: this.config.duracionTurnoMinutos,
                    gestorOrdenes: this // ‚úÖ CR√çTICO: Pasar referencia al GestorOrdenesV2
                });

                // Asignar la cola del primer equipo (t√≠picamente 'azul')
                // El panel mostrar√° todas las √≥rdenes de ese equipo
                const primerEquipo = equipos[0];
                const colaEquipo = this.colasOrdenes.get(primerEquipo);
                if (colaEquipo) {
                    this.panelCoordinacion.asignarCola(colaEquipo);
                    this.panelCoordinacion.setGestorOrdenes(this); // ‚úÖ Doble asignaci√≥n por seguridad
                    this.panelCoordinacion.inicializar();
                    this.log(`‚úÖ Panel de coordinaci√≥n inicializado (equipo: ${primerEquipo})`);
                } else {
                    this.log('‚ö†Ô∏è No se pudo asignar cola al panel de coordinaci√≥n');
                }
            }

            // Configurar men√∫ radial
            this.configurarMenuRadial();

            // Configurar eventos de mapa
            this.configurarEventosMapa();

            // Configurar eventos de teclado
            this.configurarAtajosTeclado();

            // Emitir evento de inicializaci√≥n
            this.emit('inicializado');

            this.log('‚úÖ GestorOrdenesV2 inicializado correctamente');
            return true;

        } catch (error) {
            console.error('‚ùå Error inicializando GestorOrdenesV2:', error);
            return false;
        }
    }

    /**
     * Configura el men√∫ radial para crear √≥rdenes
     */
    configurarMenuRadial() {
        if (!this.menuRadial) {
            this.log('‚ö†Ô∏è Men√∫ radial no disponible');
            return;
        }

        // Verificar si MENU_ITEMS existe en MiRadial
        if (typeof window.MENU_ITEMS !== 'undefined') {
            // Agregar items V2 para elementos (unidades)
            if (!window.MENU_ITEMS.elemento) {
                window.MENU_ITEMS.elemento = [];
            }

            // Inyectar opciones de √≥rdenes V2
            window.MENU_ITEMS.elemento = [
                {
                    title: 'Mover',
                    action: 'ordenMovimiento',
                    icon: 'fas fa-arrows-alt',
                    tooltip: 'Dar orden de movimiento'
                },
                {
                    title: 'Atacar',
                    action: 'ordenAtaque',
                    icon: 'fas fa-crosshairs',
                    tooltip: 'Dar orden de ataque'
                },
                {
                    title: 'Defender',
                    action: 'ordenDefensa',
                    icon: 'fas fa-shield-alt',
                    tooltip: 'Dar orden de defensa'
                },
                {
                    title: 'Ver √ìrdenes',
                    action: 'verOrdenesUnidad',
                    icon: 'fas fa-list',
                    tooltip: 'Ver √≥rdenes de esta unidad'
                },
                {
                    title: 'Cerrar',
                    action: 'close',
                    icon: 'fas fa-times',
                    tooltip: 'Cerrar men√∫'
                }
            ];

            this.log('‚úÖ Items de men√∫ V2 inyectados en MENU_ITEMS.elemento');
        }

        // Registrar acciones del men√∫ globalmente
        this.registrarAccionesMenu();

        this.log('‚úÖ Men√∫ radial configurado para √≥rdenes V2');
    }

    /**
     * Registra las acciones del men√∫ radial
     */
    registrarAccionesMenu() {
        // Registrar acciones globalmente para que MiRadial las encuentre
        window.ordenMovimiento = (elemento) => {
            this.iniciarOrdenMovimiento({ elemento: elemento || window.elementoSeleccionado });
        };

        window.ordenAtaque = (elemento) => {
            this.iniciarOrdenAtaque({ elemento: elemento || window.elementoSeleccionado });
        };

        window.ordenDefensa = (elemento) => {
            this.iniciarOrdenDefensa({ elemento: elemento || window.elementoSeleccionado });
        };

        window.ordenEspera = (elemento) => {
            this.iniciarOrdenEspera({ elemento: elemento || window.elementoSeleccionado });
        };

        window.ordenReconocimiento = (elemento) => {
            this.iniciarOrdenReconocimiento({ elemento: elemento || window.elementoSeleccionado });
        };

        window.desplegarSubordinados = (elemento) => {
            this.desplegarSubordinados({ elemento: elemento || window.elementoSeleccionado });
        };

        window.reagruparSubordinados = (elemento) => {
            this.reagruparSubordinados({ elemento: elemento || window.elementoSeleccionado });
        };

        window.verOrdenesUnidad = (elemento) => {
            this.mostrarOrdenesUnidad({ elemento: elemento || window.elementoSeleccionado });
        };

        // Tambi√©n crear window.acciones para compatibilidad con miradial.js
        if (!window.acciones) {
            window.acciones = {};
        }

        window.acciones.ejecutarAccion = (action, elemento) => {
            this.log(`üé¨ Ejecutando acci√≥n: ${action}`);

            switch(action) {
                case 'ordenMovimiento':
                    window.ordenMovimiento(elemento);
                    break;
                case 'ordenAtaque':
                    window.ordenAtaque(elemento);
                    break;
                case 'ordenDefensa':
                    window.ordenDefensa(elemento);
                    break;
                case 'ordenEsperar':
                    window.ordenEsperar(elemento);
                    break;
                case 'ordenReconocimiento':
                    window.ordenReconocimiento(elemento);
                    break;
                case 'verOrdenesUnidad':
                    window.verOrdenesUnidad(elemento);
                    break;
                default:
                    this.log(`‚ö†Ô∏è Acci√≥n desconocida: ${action}`);
            }
        };

        this.log('‚úÖ Acciones de men√∫ registradas globalmente');
    }

    /**
     * Configura eventos del mapa para interacci√≥n
     */
    configurarEventosMapa() {
        if (!this.map) return;

        // Click en el mapa durante modo orden
        this.map.on('click', (e) => {
            if (this.modoOrden) {
                this.procesarClickOrden(e);
            }
        });

        // Mousemove para preview de ruta
        this.map.on('mousemove', (e) => {
            if (this.modoOrden === 'movimiento' && this.unidadSeleccionada) {
                this.actualizarPreviewRuta(e.latlng);
            } else if (this.modoOrden === 'ataque' && this.unidadSeleccionada) {
                this.actualizarPreviewAtaque(e.latlng);
            }
        });

        this.log('‚úÖ Eventos de mapa configurados');
    }

    /**
     * Configura atajos de teclado
     */
    configurarAtajosTeclado() {
        document.addEventListener('keydown', (e) => {
            // ESC para cancelar orden actual
            if (e.key === 'Escape' && this.modoOrden) {
                this.cancelarOrdenActual();
            }

            // Z para deshacer √∫ltima orden (si permitido)
            if (e.ctrlKey && e.key === 'z' && this.config.permitirDeshacer) {
                this.deshacerUltimaOrden();
            }

            // Espacio para pausar/resumir ejecuci√≥n
            if (e.key === ' ' && this.subfaseActual === 'ejecucion') {
                this.togglePausaEjecucion();
            }
        });

        this.log('‚úÖ Atajos de teclado configurados');
    }

    // =====================================================
    // CREACI√ìN DE √ìRDENES
    // =====================================================

    /**
     * Inicia el proceso de dar una orden de movimiento
     */
    iniciarOrdenMovimiento(contexto) {
        this.log('üö∂ Iniciando orden de MOVIMIENTO con C√ÅLCULO DE MARCHA...');

        // Obtener unidad desde contexto
        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // üîí VALIDAR PROPIEDAD
        const jugadorActual = window.jugadorActual;
        const jugadorUnidad = unidad.options?.jugador || unidad.jugador;
        
        if (jugadorActual && jugadorUnidad && jugadorUnidad !== jugadorActual) {
            this.mostrarNotificacion(`üö´ No puedes dar √≥rdenes a elementos de ${jugadorUnidad}`, 'error');
            console.warn(`üö´ Intento bloqueado: ${jugadorActual} -> ${jugadorUnidad}`);
            return;
        }

        this.unidadSeleccionada = unidad;
        this.modoOrden = 'movimiento';
        this.origenOrden = this.obtenerPosicionUnidad(unidad);

        // üéØ ABRIR PANEL DE MARCHA para trazar ruta
        // El panel de marcha calcular√°:
        // - Vegetaci√≥n en cada punto del camino
        // - Altimetr√≠a (subidas/bajadas)
        // - Velocidad promedio seg√∫n terreno
        // - Tiempo estimado de marcha
        // - Dibuja PI/PT autom√°ticamente
        if (typeof abrirPanelMarcha === 'function') {
            abrirPanelMarcha();
            this.mostrarNotificacion('üó∫Ô∏è Traza la ruta de marcha punto por punto', 'info');
            this.log('‚úÖ Panel de marcha activado para orden de movimiento');
        } else {
            // Fallback: modo simple
            this.map.getContainer().style.cursor = 'crosshair';
            this.mostrarNotificacion('üìç Click en el destino para mover', 'info');
            this.log('‚ö†Ô∏è Panel de marcha no disponible - usando modo simple');
        }

        // Ocultar men√∫ radial
        if (this.menuRadial) {
            this.menuRadial.hideMenu();
        }
    }

    /**
     * Inicia el proceso de dar una orden de ataque
     */
    iniciarOrdenAtaque(contexto) {
        this.log('‚öîÔ∏è Iniciando orden de ATAQUE (2 pasos: eje + objetivo)...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // üîí VALIDAR PROPIEDAD
        const jugadorActual = window.jugadorActual;
        const jugadorUnidad = unidad.options?.jugador || unidad.jugador;
        
        if (jugadorActual && jugadorUnidad && jugadorUnidad !== jugadorActual) {
            this.mostrarNotificacion(`üö´ No puedes dar √≥rdenes a elementos de ${jugadorUnidad}`, 'error');
            console.warn(`üö´ Intento bloqueado: ${jugadorActual} -> ${jugadorUnidad}`);
            return;
        }

        this.unidadSeleccionada = unidad;
        this.modoOrden = 'ataque';
        this.origenOrden = this.obtenerPosicionUnidad(unidad);
        this.ejeAtaqueDefinido = false; // Control de 2 pasos
        this.ejeAtaque = null; // Guardar eje de avance

        this.map.getContainer().style.cursor = 'crosshair';
        
        // PASO 1: Definir EJE DE AVANCE (direcci√≥n de ataque)
        this.mostrarNotificacion('üéØ PASO 1/2: Marca el EJE DE AVANCE', 'info');
        this.log('üìç Esperando eje de avance...');

        if (this.menuRadial) {
            this.menuRadial.hideMenu();
        }
    }

    /**
     * Inicia orden de defensa
     */
    iniciarOrdenDefensa(contexto) {
        this.log('üõ°Ô∏è Iniciando orden de defensa...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // Crear orden de defensa directamente (no requiere selecci√≥n)
        this.crearOrdenDefensa(unidad);
    }

    /**
     * Inicia orden de espera
     */
    iniciarOrdenEspera(contexto) {
        this.log('‚è±Ô∏è Iniciando orden de espera...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // Mostrar di√°logo para especificar duraci√≥n y modalidad
        this.mostrarDialogoEspera((opciones) => {
            this.crearOrdenEspera(unidad, opciones);
        });
    }

    /**
     * Inicia orden de reconocimiento
     */
    iniciarOrdenReconocimiento(contexto) {
        this.log('üîç Iniciando orden de reconocimiento...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // üîí VALIDAR PROPIEDAD
        const jugadorActual = window.jugadorActual;
        const jugadorUnidad = unidad.options?.jugador || unidad.jugador;
        
        if (jugadorActual && jugadorUnidad && jugadorUnidad !== jugadorActual) {
            this.mostrarNotificacion(`üö´ No puedes dar √≥rdenes a elementos de ${jugadorUnidad}`, 'error');
            console.warn(`üö´ Intento bloqueado: ${jugadorActual} -> ${jugadorUnidad}`);
            return;
        }

        this.mostrarNotificacion('üó∫Ô∏è Haz click en el √°rea objetivo para reconocimiento', 'info');
        this.modoOrden = 'reconocimiento';
        this.unidadSeleccionada = unidad;

        // Cambiar cursor
        if (this.map) {
            this.map.getContainer().style.cursor = 'crosshair';
        }
    }

    /**
     * Procesa el click para completar una orden
     */
    procesarClickOrden(e) {
        const latlng = e.latlng;

        if (this.modoOrden === 'movimiento') {
            this.crearOrdenMovimiento(this.unidadSeleccionada, latlng);
        } else if (this.modoOrden === 'ataque') {
            this.crearOrdenAtaque(this.unidadSeleccionada, latlng);
        } else if (this.modoOrden === 'reconocimiento') {
            this.crearOrdenReconocimiento(this.unidadSeleccionada, latlng);
        }

        // Limpiar modo orden
        this.cancelarOrdenActual();
    }

    /**
     * Crea una orden de movimiento
     */
    crearOrdenMovimiento(unidad, destino) {
        try {
            const origen = this.obtenerPosicionUnidad(unidad);
            const hexDestino = this.hexGrid ? this.hexGrid.getHexagonAt(destino) : destino;

            if (!hexDestino) {
                this.mostrarNotificacion('‚ö†Ô∏è Posici√≥n de destino inv√°lida', 'warning');
                return;
            }

            // üéØ USAR FUNCI√ìN CENTRALIZADA
            const datosElemento = window.obtenerDatosElemento(unidad);
            
            if (!datosElemento || !window.validarDatosElemento(datosElemento)) {
                this.mostrarNotificacion('‚ö†Ô∏è Datos de elemento inv√°lidos', 'error');
                return;
            }

            // üéØ ID REAL del marcador (para poder buscarlo despu√©s)
            const unidadId = `${datosElemento.designacion}/${datosElemento.dependencia}`;
            
            if (!unidadId) {
                console.error('‚ùå Marcador sin ID v√°lido');
                this.mostrarNotificacion('‚ö†Ô∏è Marcador sin ID', 'error');
                return;
            }

            // Crear instancia de OrdenMovimiento con datos completos
            const orden = new OrdenMovimiento({
                unidadId: unidadId,
                origen: origen,
                destino: hexDestino,
                prioridad: 1,
                unidadRef: unidad,
                datosElemento: datosElemento // üéØ Del marcador REAL
            });

            // Agregar a cola del equipo
            const cola = this.colasOrdenes.get(datosElemento.equipo);
            if (cola) {
                cola.agregarOrden(orden);
                this.log(`‚úÖ Orden de movimiento: ${datosElemento.nombreCompleto}`);

                this.actualizarPanelCoordinacion();
                this.mostrarNotificacion(`‚úÖ Orden de movimiento: ${datosElemento.nombreCompleto}`, 'success');
            } else {
                this.mostrarNotificacion(`‚ö†Ô∏è Equipo ${datosElemento.equipo} no encontrado`, 'warning');
            }

        } catch (error) {
            console.error('‚ùå Error creando orden de movimiento:', error);
            this.mostrarNotificacion('‚ùå Error creando orden', 'error');
        }
    }
    crearOrdenAtaque(unidad, objetivo) {
        try {
            const origen = this.obtenerPosicionUnidad(unidad);
            const hexObjetivo = this.hexGrid ? this.hexGrid.getHexagonAt(objetivo) : objetivo;

            if (!hexObjetivo) {
                this.mostrarNotificacion('‚ö†Ô∏è Objetivo inv√°lido', 'warning');
                return;
            }

            // üéØ USAR FUNCI√ìN CENTRALIZADA
            const datosElemento = window.obtenerDatosElemento(unidad);
            
            if (!datosElemento || !window.validarDatosElemento(datosElemento)) {
                this.mostrarNotificacion('‚ö†Ô∏è Datos de elemento inv√°lidos', 'error');
                return;
            }

            // üéØ ID REAL del marcador (para poder buscarlo despu√©s)
            const unidadId = `${datosElemento.designacion}/${datosElemento.dependencia}`;
            
            if (!unidadId) {
                console.error('‚ùå Marcador sin ID v√°lido');
                this.mostrarNotificacion('‚ö†Ô∏è Marcador sin ID', 'error');
                return;
            }

            // Crear instancia de OrdenAtaque
            const orden = new OrdenAtaque({
                unidadId: unidadId,
                origen: origen,
                objetivo: hexObjetivo,
                prioridad: 2,
                unidadRef: unidad // Guardar referencia al marcador
            });

            // Agregar a cola
            const cola = this.colasOrdenes.get(datosElemento.equipo);
            if (cola) {
                cola.agregarOrden(orden);
                this.log(`‚úÖ Orden de ataque: ${datosElemento.nombreCompleto}`);

                this.actualizarPanelCoordinacion();
                this.mostrarNotificacion(`‚úÖ Orden de ataque: ${datosElemento.nombreCompleto}`, 'success');
            } else {
                this.mostrarNotificacion(`‚ö†Ô∏è Equipo ${datosElemento.equipo} no encontrado`, 'warning');
            }

        } catch (error) {
            console.error('‚ùå Error creando orden de ataque:', error);
            this.mostrarNotificacion('‚ùå Error creando orden', 'error');
        }
    }

    /**
     * Crea orden de defensa
     */
    crearOrdenDefensa(unidad, opciones = {}) {
        this.log('üõ°Ô∏è Creando orden de defensa');

        if (typeof OrdenDefensa === 'undefined') {
            this.mostrarNotificacion('‚ùå OrdenDefensa no disponible', 'error');
            return null;
        }

        try {
            // üéØ USAR FUNCI√ìN CENTRALIZADA
            const datosElemento = window.obtenerDatosElemento(unidad);
            
            if (!datosElemento || !window.validarDatosElemento(datosElemento)) {
                this.mostrarNotificacion('‚ö†Ô∏è Datos de elemento inv√°lidos', 'error');
                return null;
            }

            // üéØ ID REAL del marcador (para poder buscarlo despu√©s)
            const unidadId = `${datosElemento.designacion}/${datosElemento.dependencia}`;
            
            if (!unidadId) {
                console.error('‚ùå Marcador sin ID v√°lido');
                this.mostrarNotificacion('‚ö†Ô∏è Marcador sin ID', 'error');
                return null;
            }

            // Obtener posici√≥n actual de la unidad
            const posicion = unidad.getLatLng ? unidad.getLatLng() : null;

            if (!posicion) {
                this.mostrarNotificacion('‚ùå No se pudo determinar la posici√≥n de la unidad', 'error');
                return null;
            }

            // Crear instancia de orden
            const orden = new OrdenDefensa(unidad, posicion, opciones);

            // Validar orden
            orden.validar().then(esValida => {
                if (esValida) {
                    // Agregar a la cola del equipo
                    const equipo = unidad.options?.equipo || 'azul';
                    const cola = this.colasOrdenes.get(datosElemento.equipo);
                    if (cola) cola.agregarOrden(orden);
                    this.mostrarNotificacion(`‚úÖ Orden de defensa agregada (${orden.tipoDefensa})`, 'success');
                } else {
                    this.mostrarNotificacion(`‚ùå Orden inv√°lida: ${orden.mensajesValidacion.join(', ')}`, 'error');
                }
            });

            return orden;

        } catch (error) {
            console.error('Error creando orden de defensa:', error);
            this.mostrarNotificacion('‚ùå Error al crear orden de defensa', 'error');
            return null;
        }
    }

    /**
     * Crea orden de espera
     */
    crearOrdenEspera(unidad, opciones = {}) {
        this.log('‚è±Ô∏è Creando orden de espera');

        if (typeof OrdenEspera === 'undefined') {
            this.mostrarNotificacion('‚ùå OrdenEspera no disponible', 'error');
            return null;
        }

        try {
            // üéØ USAR FUNCI√ìN CENTRALIZADA
            const datosElemento = window.obtenerDatosElemento(unidad);
            
            if (!datosElemento || !window.validarDatosElemento(datosElemento)) {
                this.mostrarNotificacion('‚ö†Ô∏è Datos de elemento inv√°lidos', 'error');
                return null;
            }

            // üéØ ID REAL del marcador (para poder buscarlo despu√©s)
            const unidadId = `${datosElemento.designacion}/${datosElemento.dependencia}`;
            
            if (!unidadId) {
                console.error('‚ùå Marcador sin ID v√°lido');
                this.mostrarNotificacion('‚ö†Ô∏è Marcador sin ID', 'error');
                return null;
            }

            // Crear instancia de orden
            const orden = new OrdenEspera(unidad, opciones);

            // Validar orden
            orden.validar().then(esValida => {
                if (esValida) {
                    // Agregar a la cola del equipo
                    const equipo = unidad.options?.equipo || 'azul';
                    const cola = this.colasOrdenes.get(datosElemento.equipo);
                    if (cola) cola.agregarOrden(orden);
                    this.mostrarNotificacion(`‚úÖ Orden de espera agregada (${orden.modalidad}, ${orden.duracion}s)`, 'success');
                } else {
                    this.mostrarNotificacion(`‚ùå Orden inv√°lida: ${orden.mensajesValidacion.join(', ')}`, 'error');
                }
            });

            return orden;

        } catch (error) {
            console.error('Error creando orden de espera:', error);
            this.mostrarNotificacion('‚ùå Error al crear orden de espera', 'error');
            return null;
        }
    }

    /**
     * Crea orden de reconocimiento
     */
    crearOrdenReconocimiento(unidad, objetivo, opciones = {}) {
        this.log('üîç Creando orden de reconocimiento');

        if (typeof OrdenReconocimiento === 'undefined') {
            this.mostrarNotificacion('‚ùå OrdenReconocimiento no disponible', 'error');
            return null;
        }

        try {
            // üéØ USAR FUNCI√ìN CENTRALIZADA
            const datosElemento = window.obtenerDatosElemento(unidad);
            
            if (!datosElemento || !window.validarDatosElemento(datosElemento)) {
                this.mostrarNotificacion('‚ö†Ô∏è Datos de elemento inv√°lidos', 'error');
                return null;
            }

            // üéØ ID REAL del marcador (para poder buscarlo despu√©s)
            const unidadId = `${datosElemento.designacion}/${datosElemento.dependencia}`;
            
            if (!unidadId) {
                console.error('‚ùå Marcador sin ID v√°lido');
                this.mostrarNotificacion('‚ö†Ô∏è Marcador sin ID', 'error');
                return null;
            }

            // Crear instancia de orden
            const orden = new OrdenReconocimiento(unidad, objetivo, opciones);

            // Validar orden
            orden.validar().then(esValida => {
                if (esValida) {
                    // Agregar a la cola del equipo
                    const equipo = unidad.options?.equipo || 'azul';
                    const cola = this.colasOrdenes.get(datosElemento.equipo);
                    if (cola) cola.agregarOrden(orden);
                    this.mostrarNotificacion(`‚úÖ Orden de reconocimiento agregada (${orden.tipoReconocimiento})`, 'success');
                } else {
                    this.mostrarNotificacion(`‚ùå Orden inv√°lida: ${orden.mensajesValidacion.join(', ')}`, 'error');
                }
            });

            return orden;

        } catch (error) {
            console.error('Error creando orden de reconocimiento:', error);
            this.mostrarNotificacion('‚ùå Error al crear orden de reconocimiento', 'error');
            return null;
        }
    }

    // =====================================================
    // VISUALIZACI√ìN Y PREVIEW
    // =====================================================

    /**
     * Actualiza preview de ruta durante movimiento del mouse
     */
    actualizarPreviewRuta(destino) {
        // ‚ùå DESHABILITADO - Ya NO se usa pathfinding
        // El C√ÅLCULO DE MARCHA maneja el preview de ruta autom√°ticamente
        // cuando el usuario traza la l√≠nea en el panel de marcha
        return;
    }

    /**
     * Actualiza preview de l√≠nea de ataque
     * PASO 1: Mostrar eje de avance
     * PASO 2: Mostrar objetivo
     */
    actualizarPreviewAtaque(objetivo) {
        if (!this.unidadSeleccionada) return;

        const origen = this.obtenerPosicionUnidad(this.unidadSeleccionada);
        
        if (!origen || !objetivo) return;

        // Si a√∫n no se defini√≥ el eje de avance (PASO 1)
        if (!this.ejeAtaqueDefinido) {
            // Dibujar l√≠nea temporal del eje de avance
            this.dibujarPreviewLinea(origen, objetivo, '#ff9900', 'Eje de Avance');
        } else {
            // PASO 2: Mostrar objetivo
            // El eje ya est√° definido, ahora marcar el objetivo
            this.dibujarPreviewLinea(this.ejeAtaque, objetivo, '#ff0000', 'Objetivo');
        }
    }

    /**
     * Dibuja preview de ruta en el mapa
     */
    dibujarPreviewRuta(ruta) {
        // Limpiar preview anterior
        if (this.previewRuta) {
            this.map.removeLayer(this.previewRuta);
        }

        // Convertir ruta a LatLngs
        const latlngs = ruta.map(hex => this.hexGrid.hexToLatLng(hex));

        // Crear polyline
        this.previewRuta = L.polyline(latlngs, {
            color: '#00ff00',
            weight: 3,
            opacity: 0.7,
            dashArray: '10, 5'
        }).addTo(this.map);
    }

    /**
     * Dibuja preview de l√≠nea de ataque
     */
    dibujarPreviewLinea(origen, destino) {
        // Limpiar preview anterior
        if (this.previewLinea) {
            this.map.removeLayer(this.previewLinea);
        }

        const origenLatLng = this.hexGrid.hexToLatLng(origen);
        const destinoLatLng = this.hexGrid.hexToLatLng(destino);

        // Crear polyline
        this.previewLinea = L.polyline([origenLatLng, destinoLatLng], {
            color: '#ff0000',
            weight: 2,
            opacity: 0.7,
            dashArray: '5, 5'
        }).addTo(this.map);
    }

    /**
     * Limpia previews visuales
     */
    limpiarPreviews() {
        if (this.previewRuta) {
            this.map.removeLayer(this.previewRuta);
            this.previewRuta = null;
        }
        if (this.previewLinea) {
            this.map.removeLayer(this.previewLinea);
            this.previewLinea = null;
        }
    }

    /**
     * Cancela la orden actual en progreso
     */
    cancelarOrdenActual() {
        this.modoOrden = null;
        this.origenOrden = null;
        this.destinoOrden = null;
        this.limpiarPreviews();
        this.map.getContainer().style.cursor = '';
        this.mostrarNotificacion('‚ùå Orden cancelada', 'info');
    }

    // =====================================================
    // SUBFASES DE COMBATE
    // =====================================================

    /**
     * Cambia a subfase de impartici√≥n de √≥rdenes
     */
    iniciarPlanificacion() {
        this.log('üìã Iniciando fase de IMPARTICI√ìN DE √ìRDENES');
        this.subfaseActual = 'imparticion';
        this.logEventosTurno = [];

        // Habilitar interfaz para dar √≥rdenes
        this.habilitarInterfazOrdenes(true);

        // ‚úÖ NO mostrar panel autom√°ticamente - el usuario lo abrir√° con el bot√≥n
        // if (this.panelCoordinacion) {
        //     this.panelCoordinacion.mostrar();
        // }

        this.emit('subfaseCambiada', { subfase: 'imparticion', turno: this.turnoActual });
        this.mostrarNotificacion(`üìã Turno ${this.turnoActual} - Impartici√≥n de √ìrdenes`, 'info');
    }

    /**
     * Confirma √≥rdenes y pasa a ejecuci√≥n
     */
    async confirmarOrdenes() {
        this.log('‚úÖ Confirmando √≥rdenes...');

        // Validar todas las √≥rdenes
        let todasValidas = true;
        for (const [equipo, cola] of this.colasOrdenes) {
            const resultado = await cola.validarTodasLasOrdenes();
            if (!resultado.exito) {
                todasValidas = false;
                this.mostrarNotificacion(`‚ö†Ô∏è Errores en √≥rdenes del equipo ${equipo}`, 'warning');
                console.log('Errores:', resultado.errores);
            }
        }

        if (!todasValidas) {
            this.mostrarNotificacion('‚ùå Corrige los errores antes de confirmar', 'error');
            return false;
        }

        // Pasar a ejecuci√≥n
        await this.iniciarEjecucion();
        return true;
    }

    /**
     * Inicia fase de ejecuci√≥n de √≥rdenes
     */
    async iniciarEjecucion() {
        this.log('‚ö° Iniciando fase de EJECUCI√ìN');
        this.subfaseActual = 'ejecucion';

        // Deshabilitar interfaz
        this.habilitarInterfazOrdenes(false);

        this.emit('subfaseCambiada', { subfase: 'ejecucion', turno: this.turnoActual });
        this.mostrarNotificacion(`‚ö° Turno ${this.turnoActual} - Ejecutando √≥rdenes...`, 'info');

        // Ejecutar √≥rdenes de todos los equipos simult√°neamente
        const promesas = [];
        for (const [equipo, cola] of this.colasOrdenes) {
            promesas.push(this.ejecutarOrdenesEquipo(equipo, cola));
        }

        await Promise.all(promesas);

        // Pasar a revisi√≥n
        this.iniciarRevision();
    }

    /**
     * Ejecuta √≥rdenes de un equipo
     */
    async ejecutarOrdenesEquipo(equipo, cola) {
        this.log(`‚ö° Ejecutando √≥rdenes del equipo ${equipo}`);

        const resultado = await cola.ejecutarOrdenesSecuencialmente();

        // Registrar en log
        this.logEventosTurno.push({
            equipo: equipo,
            eventos: resultado.resultados
        });

        return resultado;
    }

    /**
     * Inicia fase de revisi√≥n
     */
    iniciarRevision() {
        this.log('üìä Iniciando fase de REVISI√ìN');
        this.subfaseActual = 'revision';

        this.emit('subfaseCambiada', { subfase: 'revision', turno: this.turnoActual });
        this.mostrarNotificacion(`üìä Turno ${this.turnoActual} - Revisi√≥n de resultados`, 'info');

        // Mostrar log de eventos
        this.mostrarLogTurno();

        // Actualizar panel con resultados
        this.actualizarPanelCoordinacion();
    }

    /**
     * Finaliza turno y pasa al siguiente
     */
    finalizarTurno() {
        this.log(`‚úÖ Finalizando turno ${this.turnoActual}`);

        // Incrementar turno
        this.turnoActual++;
        this.tiempoSimuladoMinutos += this.config.duracionTurnoMinutos;

        // Limpiar √≥rdenes ejecutadas
        for (const [equipo, cola] of this.colasOrdenes) {
            cola.limpiarOrdenesCompletadas();
        }

        this.emit('turnoFinalizado', { turno: this.turnoActual - 1 });

        // Volver a impartici√≥n de √≥rdenes
        this.iniciarPlanificacion();
    }

    // =====================================================
    // INTERFAZ Y PANEL
    // =====================================================

    /**
     * Actualiza el panel de coordinaci√≥n
     */
    actualizarPanelCoordinacion() {
        if (!this.panelCoordinacion) return;

        // Recopilar todas las √≥rdenes de todos los equipos
        const todasLasOrdenes = [];
        for (const [equipo, cola] of this.colasOrdenes) {
            const ordenes = cola.obtenerTodasLasOrdenes();
            todasLasOrdenes.push(...ordenes);
        }

        // Actualizar panel (renderizar muestra las √≥rdenes de la cola asignada)
        this.panelCoordinacion.renderizar();
    }

    /**
     * Habilita/deshabilita interfaz de √≥rdenes
     */
    habilitarInterfazOrdenes(habilitar) {
        // TODO: Implementar bloqueo de UI durante ejecuci√≥n
        if (habilitar) {
            this.log('üîì Interfaz de √≥rdenes habilitada');
        } else {
            this.log('üîí Interfaz de √≥rdenes deshabilitada');
        }
    }

    /**
     * Muestra el log de eventos del turno
     */
    mostrarLogTurno() {
        console.group(`üìä LOG TURNO ${this.turnoActual}`);
        for (const log of this.logEventosTurno) {
            console.log(`\nüéØ Equipo: ${log.equipo}`);
            console.table(log.eventos);
        }
        console.groupEnd();

        // TODO: Mostrar en UI panel de revisi√≥n
    }

    /**
     * Muestra las √≥rdenes de una unidad
     */
    mostrarOrdenesUnidad(contexto) {
        const unidad = contexto.elemento || contexto.unidad;
        if (!unidad) return;

        const cola = this.colasOrdenes.get(unidad.equipo);
        if (!cola) return;

        const ordenesUnidad = cola.obtenerOrdenesDeUnidad(unidad.id);

        console.group(`üìã √ìrdenes de ${unidad.id}`);
        console.table(ordenesUnidad.map(o => ({
            tipo: o.tipo,
            estado: o.estado,
            prioridad: o.prioridad,
            duracionMin: o.duracionEstimadaMinutos
        })));
        console.groupEnd();

        // TODO: Mostrar en UI panel
        this.mostrarNotificacion(`üìã ${ordenesUnidad.length} orden(es) - Ver consola`, 'info');
    }

    /**
     * Despliega subordinados de una unidad seg√∫n ORBAT
     */
    async desplegarSubordinados(contexto) {
        this.log('üéñÔ∏è Desplegando subordinados...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // Verificar que ORBATManager est√© disponible
        if (typeof window.orbatManager === 'undefined') {
            this.mostrarNotificacion('‚ùå Sistema ORBAT no disponible', 'error');
            console.error('ORBATManager no est√° cargado');
            return;
        }

        // Configurar el mapa en ORBATManager si no lo est√°
        if (!window.orbatManager.map && this.map) {
            window.orbatManager.setMap(this.map);
        }

        // Verificar si la unidad puede desplegar subordinados
        const sidc = unidad.options?.sidc;
        if (!sidc) {
            this.mostrarNotificacion('‚ùå La unidad no tiene SIDC', 'error');
            return;
        }

        const puedeDesplegar = window.orbatManager.puedeDesplegar(sidc);
        if (!puedeDesplegar) {
            const magnitudInfo = window.orbatManager.obtenerInfoMagnitud(window.orbatManager.extraerMagnitud(sidc));
            this.mostrarNotificacion(`‚ö†Ô∏è ${magnitudInfo?.nombre || 'Esta unidad'} no tiene subordinados definidos en ORBAT`, 'warning');
            return;
        }

        const cantidad = window.orbatManager.contarSubordinados(sidc);
        this.mostrarNotificacion(`üéñÔ∏è Desplegando ${cantidad} subordinados...`, 'info');

        try {
            // Desplegar subordinados
            const subordinados = await window.orbatManager.desplegarSubordinados(unidad, {
                formacion: 'linea' // Puede ser configurable
            });

            if (subordinados && subordinados.length > 0) {
                this.mostrarNotificacion(`‚úÖ ${subordinados.length} subordinados desplegados`, 'success');
                this.log(`‚úÖ Desplegados: ${subordinados.map(s => s.options.nombre).join(', ')}`);
            } else {
                this.mostrarNotificacion('‚ö†Ô∏è No se pudieron desplegar subordinados', 'warning');
            }

        } catch (error) {
            console.error('Error desplegando subordinados:', error);
            this.mostrarNotificacion('‚ùå Error al desplegar subordinados', 'error');
        }
    }

    /**
     * üîÑ Reagrupa subordinados de una unidad (los oculta/elimina del mapa)
     */
    reagruparSubordinados(contexto) {
        this.log('üîÑ Reagrupando subordinados...');

        const unidad = contexto.elemento || contexto.unidad || this.unidadSeleccionada;
        if (!unidad) {
            this.mostrarNotificacion('‚ö†Ô∏è Selecciona una unidad primero', 'warning');
            return;
        }

        // Verificar que ORBATManager est√© disponible
        if (typeof window.orbatManager === 'undefined') {
            this.mostrarNotificacion('‚ùå Sistema ORBAT no disponible', 'error');
            return;
        }

        // Verificar si la unidad tiene subordinados desplegados
        if (!window.orbatManager.tieneSubordinadosDesplegados(unidad)) {
            this.mostrarNotificacion('‚ö†Ô∏è Esta unidad no tiene subordinados desplegados', 'warning');
            return;
        }

        const cantidad = unidad.subordinadosDesplegados ? unidad.subordinadosDesplegados.length : 0;
        this.mostrarNotificacion(`üîÑ Reagrupando ${cantidad} subordinados...`, 'info');

        try {
            // Reagrupar subordinados
            const reagrupados = window.orbatManager.reagruparSubordinados(unidad);

            if (reagrupados > 0) {
                this.mostrarNotificacion(`‚úÖ ${reagrupados} subordinados reagrupados`, 'success');
                this.log(`‚úÖ Reagrupados ${reagrupados} subordinados`);
            } else {
                this.mostrarNotificacion('‚ö†Ô∏è No se pudieron reagrupar subordinados', 'warning');
            }

        } catch (error) {
            console.error('Error reagrupando subordinados:', error);
            this.mostrarNotificacion('‚ùå Error al reagrupar subordinados', 'error');
        }
    }

    /**
     * Obtiene opciones de men√∫ seg√∫n tipo de arma (doctrina)
     * @param {Object} unidad - Unidad (marker de Leaflet)
     * @returns {Array} Items del men√∫ radial
     */
    obtenerOpcionesMenu(unidad) {
        // Delegar a MenusDoctrinales si est√° disponible
        if (typeof MenusDoctrinales !== 'undefined') {
            return MenusDoctrinales.obtenerMenu(unidad);
        }

        // Fallback: men√∫ gen√©rico
        return [
            { title: 'Mover', action: 'ordenMovimiento', icon: 'fas fa-arrows-alt', tooltip: 'Dar orden de movimiento' },
            { title: 'Atacar', action: 'ordenAtaque', icon: 'fas fa-crosshairs', tooltip: 'Dar orden de ataque' },
            { title: 'Defender', action: 'ordenDefensa', icon: 'fas fa-shield-alt', tooltip: 'Dar orden de defensa' },
            { title: 'Reconocer', action: 'ordenReconocimiento', icon: 'fas fa-binoculars', tooltip: 'Orden de reconocimiento' },
            { title: 'Esperar', action: 'ordenEspera', icon: 'fas fa-pause', tooltip: 'Esperar este turno' }
        ];
    }

    // =====================================================
    // UTILIDADES
    // =====================================================

    /**
     * Obtiene la posici√≥n de una unidad (marcador L.marker)
     */
    obtenerPosicionUnidad(unidad) {
        // Si es un marcador de Leaflet (sistema SIDC existente)
        if (unidad && typeof unidad.getLatLng === 'function') {
            const latlng = unidad.getLatLng();
            if (this.hexGrid && typeof this.hexGrid.getHexagonAt === 'function') {
                return this.hexGrid.getHexagonAt(latlng);
            }
            return latlng;
        }

        // Fallback para otros formatos
        if (unidad.hex) return unidad.hex;
        if (unidad.posicion) return unidad.posicion;
        if (unidad.latlng) {
            return this.hexGrid ? this.hexGrid.getHexagonAt(unidad.latlng) : unidad.latlng;
        }

        return null;
    }

    /**
     * Muestra una notificaci√≥n al usuario
     */
    mostrarNotificacion(mensaje, tipo = 'info') {
        // Integrar con sistema de notificaciones existente
        if (window.notificationSystem) {
            window.notificationSystem.show(mensaje, tipo);
        } else {
            console.log(`[${tipo.toUpperCase()}] ${mensaje}`);
        }
    }

    /**
     * Muestra di√°logo para especificar duraci√≥n
     */

    /**
     * Muestra di√°logo para configurar orden de espera
     */
    mostrarDialogoEspera(callback) {
        // TODO: Crear di√°logo modal m√°s sofisticado
        const minutos = prompt('¬øCu√°ntos minutos esperar?', '30');
        const modalidad = confirm('¬øEspera activa? (OK = Activa, Cancelar = Pasiva)') ? 'activa' : 'pasiva';
        
        if (minutos && !isNaN(minutos)) {
            callback({
                duracion: parseInt(minutos),
                modalidad: modalidad
            });
        }
    }

    mostrarDialogoDuracion(callback) {
        const minutos = prompt('¬øCu√°ntos minutos esperar?', '30');
        if (minutos && !isNaN(minutos)) {
            callback(parseInt(minutos));
        }
    }

    /**
     * Deshace la √∫ltima orden agregada
     */
    deshacerUltimaOrden() {
        if (!this.config.permitirDeshacer) return;

        // TODO: Implementar l√≥gica de deshacer
        this.mostrarNotificacion('üöß Deshacer en desarrollo', 'info');
    }

    /**
     * Pausa/reanuda la ejecuci√≥n
     */
    togglePausaEjecucion() {
        // TODO: Implementar pausa
        this.mostrarNotificacion('üöß Pausa en desarrollo', 'info');
    }

    /**
     * Sistema de eventos
     */
    on(evento, callback) {
        if (!this.eventListeners.has(evento)) {
            this.eventListeners.set(evento, []);
        }
        this.eventListeners.get(evento).push(callback);
    }

    emit(evento, datos) {
        if (this.eventListeners.has(evento)) {
            for (const callback of this.eventListeners.get(evento)) {
                callback(datos);
            }
        }
    }

    /**
     * Logging
     */
    log(...args) {
        if (this.config.modoDebug) {
            console.log('[GestorOrdenesV2]', ...args);
        }
    }

    /**
     * Limpieza
     */
    destruir() {
        this.limpiarPreviews();
        this.eventListeners.clear();
        this.colasOrdenes.clear();
        if (this.panelCoordinacion) {
            this.panelCoordinacion.destruir();
        }
        this.log('üóëÔ∏è GestorOrdenesV2 destruido');
    }

    modificarOrden(ordenId, modificaciones) {
        console.log(`üîß Modificar orden ${ordenId}`, modificaciones);
        let ordenEncontrada = null, equipoOrden = null;
        for (const [equipo, queue] of this.colasOrdenes.entries()) {
            const ordenes = queue.obtenerTodasLasOrdenes();
            const orden = ordenes.find(o => o.id === ordenId);
            if (orden) { ordenEncontrada = orden; equipoOrden = equipo; break; }
        }
        if (!ordenEncontrada) return console.error(`‚ùå Orden ${ordenId} no encontrada`);
        if (modificaciones.turnoInicio !== undefined) ordenEncontrada.turnoInicio = modificaciones.turnoInicio;
        if (modificaciones.insertarFase) {
            const { indice, fase } = modificaciones.insertarFase;
            ordenEncontrada.insertarFase && ordenEncontrada.insertarFase(indice, fase);
        }
        if (modificaciones.modificarFase) {
            const { indice, cambios } = modificaciones.modificarFase;
            if (ordenEncontrada.fases?.[indice]) {
                Object.assign(ordenEncontrada.fases[indice], cambios);
                ordenEncontrada.calcularDuracionTotal?.();
            }
        }
        if (modificaciones.eliminarFase !== undefined) ordenEncontrada.eliminarFase?.(modificaciones.eliminarFase);
        if (modificaciones.nuevoDestino) {
            ordenEncontrada.destino = modificaciones.nuevoDestino;
            ordenEncontrada.inicializar?.();
        }
        window.eventBus?.emit('ordenModificada', { ordenId, equipo: equipoOrden, modificaciones });
        this.panelCoordinacion?.renderizar();
        return true;
    }

    /**
     * ‚ö° Ejecutar √≥rdenes del turno actual
     * Delega la ejecuci√≥n a la cola activa (equipoActual)
     */
    async ejecutarTurno() {
        if (!this.equipoActual) {
            console.error('‚ùå No hay equipo activo para ejecutar turno');
            return { exito: false, error: 'Sin equipo activo' };
        }

        const cola = this.colasOrdenes.get(this.equipoActual);
        if (!cola) {
            console.error(`‚ùå No hay cola de √≥rdenes para equipo ${this.equipoActual}`);
            return { exito: false, error: 'Cola no encontrada' };
        }

        console.log(`üöÄ Ejecutando turno ${this.turnoActual} para equipo ${this.equipoActual}...`);

        try {
            // Delegar a OrdenesQueueV2
            const resultado = await cola.ejecutarTurno(this.turnoActual);

            // Actualizar panel de coordinaci√≥n
            if (this.panelCoordinacion) {
                this.panelCoordinacion.renderizar();
            }

            // Emitir evento
            this.emit('turnoEjecutado', {
                turno: this.turnoActual,
                equipo: this.equipoActual,
                resultado
            });

            console.log(`‚úÖ Turno ${this.turnoActual} ejecutado:`, resultado);
            return resultado;

        } catch (error) {
            console.error('‚ùå Error ejecutando turno:', error);
            return { exito: false, error: error.message };
        }
    }

    cancelarOrden(ordenId, motivo = 'Cancelada por jugador') {
        console.log(`‚ùå Cancelar orden ${ordenId}: ${motivo}`);
        let ordenEncontrada = null, queueOrden = null, equipoOrden = null;
        for (const [equipo, queue] of this.colasOrdenes.entries()) {
            const ordenes = queue.obtenerTodasLasOrdenes();
            const orden = ordenes.find(o => o.id === ordenId);
            if (orden) { ordenEncontrada = orden; equipoOrden = equipo; queueOrden = queue; break; }
        }
        if (!ordenEncontrada) return console.error(`‚ùå Orden ${ordenId} no encontrada`);
        ordenEncontrada.cancelar?.();
        if (ordenEncontrada.estado === 'ejecutando' && ordenEncontrada.faseActual >= 0) {
            ordenEncontrada.fases?.[ordenEncontrada.faseActual] && (ordenEncontrada.fases[ordenEncontrada.faseActual].estado = 'fallida');
        }
        const ordenes = queueOrden.obtenerTodasLasOrdenes();
        const indice = ordenes.indexOf(ordenEncontrada);
        if (indice !== -1) ordenes.splice(indice, 1);
        window.eventBus?.emit('ordenCancelada', { ordenId, equipo: equipoOrden, motivo });
        this.panelCoordinacion?.renderizar();
        return true;
    }
}

// Exportar para uso global
window.GestorOrdenesV2 = GestorOrdenesV2;
console.log('üì¶ GestorOrdenesV2.js cargado');
